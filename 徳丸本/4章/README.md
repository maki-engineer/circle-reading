## 4.4, 4.5
# SQLインジェクション

SQLの呼び出し方に不備がある場合に発生する脆弱性。

- データベース内のすべての情報が外部から盗まれる
- データベースの内容が書き換えられる
- (IDやパスワードを用いずに)認証を回避される
- その他、データベースサーバ上のファイルの読み出し、書き込み、プログラムの実行など。

影響度・大

## エラーメッセージ経由の情報漏洩

P.153 情報漏洩を引き起こすURL(GETパラメータにSQL文を記述)

→ P.154 図4-29 エラーメッセージ経由の情報漏洩(`$yamada:pass1, (id:password)`)

→ エラーメッセージが悪用される

=> エラーメッセージには内部的なエラー内容を含まないようにする

## UNION SELECTを用いた情報漏洩

UNION SELECT: 2つのSQL文の結果の和集合を求める演算

=> 重複した部分を表示させる

## SQLインジェクションによる認証回避

パスワードに「'OR'a'="a」と入力

→SELECT * FROM users WHERE id = 'yamada' and pwd = '' OR 'a' = 'a'

=> パスワードを知らなくてもログインできる

=> データの改ざんも同様

## その他の攻撃

- OSコマンドの実行
- ファイルの読み出し
- ファイルの書き出し
- HTTPリクエストによる他のサーバへの攻撃

## 脆弱性が生まれる原因

- 文字列リテラルの問題

文字列リテラル：SQL文中で決まった値（SELECT * FROM books WHERE author = 'Shakespeare'）

シングルクォートを文字列に使用する場合はシングルクォートを重ねてエスケープする

→文字列リテラルをはみ出した部分が生じてエラーにつながる

- 数値項目に対するSQLインジェクション

スクリプト言語の場合、変数に型の制約が無いため、数値を想定した変数に数値以外の文字が入る場合がある

## 対策

- プレースホルダによりSQLを組み立て

SQL文にプレースホルダを埋め

## 4.12 (308p) ファイルのアップロードにまつわる問題
### 4.12.1 ファイルアップロードの問題の概要
#### ローカル上にあったファイルや画像などをサーバーにアップロードしてたくさんの人と共有したりするのに使うアップローダーに対する攻撃は4種類
- アップロード機能に対するDoS攻撃
- アップロードされたファイルをサーバー上のスクリプトとして実行する攻撃
- 仕掛けを含むファイルを利用者にダウンロードさせる攻撃
- 閲覧権限のないファイルのダウンロード

#### アップロード機能に対するDoS攻撃
- 影響

  ブラウザの応答速度が低下したり、サーバーが停止してしまうこともある。(例：田代砲)
- 対策

  アップロードされるファイルの容量を制限したり、リクエストボディのサイズを絞るのが有効。
  - 何故ファイルの容量を制限することによって防げるのか

    Dos攻撃の代表的な攻撃例として、Webサイトに対して過剰にアクセスをすることが挙げられるが、膨大な量のファイルをアップロードしてWebサイトの応答速度を低下させるのもDos攻撃に入る。

  また、画像もアップロードできる場合、画像のサイズや色数の上限値を設定したり、CPU負荷の高い処理が含まれる場合は、CPUの使用時間や実行時間を見積もって、それに関連するパラメータを制限するのも大事。
  - CPU負荷の高い処理を特定する方法として、New Relicを利用してボトルネックになっているロジックを特定する方法が有効。

#### アップロードされたファイルをサーバー上のスクリプトとして実行する攻撃

  - 概要

    例えばアップロードできるファイルにphpファイルなども含まれていると、そのphpファイルなどを使って、故意にスクリプトを実行させ、情報漏洩させたり他にアップロードされているファイルの内容を改ざんすることができてしまったりする。

  - 対策

    phpファイルなどがアップロードされた場合は、拡張子をカスタマイズ (.phtmlなど) してしまうか、アップロードされた拡張子の言語の処理自体を制御するのが有効。

#### 仕掛けを含むファイルを利用者にダウンロードさせる攻撃

  - 概要

    仕掛けが含まれたpdfファイルなどをアップロードし、サーバー上にいるときは悪さしないが、別の人がそのファイルを閲覧したりした瞬間にマルウェアに感染したりする。
    対策については、8章にあるマルウェア対策の部分を参照。

  - トリック

    例えばjsファイルをダウンロードをした時にJavaScriptが実行されるのは、アップロードしたファイルをサーバー上に「これはHTMLファイルですよ」と騙す仕掛けになっている。

    また、pdfファイルに関しては、Adobe Acrobat Readerに備わっているFormCalcというスクリプト言語がサーバ上で実行されてしまうリスクがある。

    そして、マルウェア感染によって被害がでた場合、仕掛けを含んだファイルをアップロードした側ももちろん悪いが、そのアップローダーを運営している側も責任を問われる可能性があるため、Webサイトの性質によっては、きちんとマルウェア感染の対策をすること。

#### 閲覧権限のないファイルのダウンロード

  - 原因

    権限をつける必要のあるファイルに適切な権限をつけることがほとんど。この攻撃の詳細については、5章にある認可の部分を参照。

### 4.12.2 アップロードファイルによるサーバー側スクリプト実行

  - 概要

    前述したように、スクリプトファイルがアップロードされて実行されると、情報漏洩させたり他にアップロードされているファイルの内容を改ざんすることができてしまったりするが、それ以外の影響としては以下が挙げられる。
    - 外部へのメールの送信
    - 別のサーバーへ攻撃 (踏み台攻撃)
    - サーバー上での暗号通貨の採掘 (マイニング)

  - 攻撃例

    ```
    <pre>
    <?php
      system('/bin/cat /etc/passwd');
    ?>
    </pre>
    ```

    上記のスクリプトファイルは、catコマンドを使って、 `/etc/passwd` の内容を表示するというもの。
    例えば画像をアップロードするアップローダーにこのスクリプトファイルをアップロードすると、画像ではないため、リンクと×印で表示される。そしてそのリンクをクリックすると、 `/etc/passwd` の内容がサーバー上で表示される。

  - 対策

    こちらも先述したように、phpファイルなどがアップロードされた場合は、拡張子をカスタマイズ (.phtmlなど) してしまうか、アップロードされた拡張子の言語の処理自体を制御するのが有効。

    - 拡張子をチェックする際の注意点

      スクリプトファイルがアップロードされるのを防ぐ方法のもう1つとして、拡張子のチェックが挙げられる。 ( jpg、png、gif 拡張子しか受け付けないよというような処理)<br>この拡張子のチェックももちろん有効だが、Apacheの設定によっては、多重拡張子によって、 .png なのにPHPの処理が実行されてしまう危険性もあるため、拡張子のチェックのみというのは、なるべく避けるべき。

      また、SSIという機能を使うと、HTMLからインクルートしたファイルをコマンドとして実行することが出来る。通常SSIを使う場合のHTMLの拡張子は .shtml だが、設定をすることによって .html でも使えるようになるので、 .html のファイルもスクリプトファイルとして扱う必要があることに注意。

### 4.12.3 ファイルダウンロードによるクロスサイト・スクリプティング

  - 概要

    利用者がアップロードされたファイルをダウンロードする際に、ブラウザがファイルタイプを間違って指定する可能性がある。例として、pdfファイルにhtmlタグを含むと、条件によってブラウザはpdfファイルじゃなくてhtmlファイルとして認識してしまい、JavaScriptのスクリプトが実行されてしまうことがある。これがファイルダウンロードによるクロスサイト・スクリプティング。

  - 対策

    - ファイルアップロード時の対策
      - 拡張子が許可されたものかをチェックする
    - ファイルダウンロード時の対策
      - Content-Typeを正しく設定する
      - レスポンスメッセージのヘッダに `X-Content-Type-Options: nosniff` を指定する

        Apacheの場合は

        `Header always append X-Content-Type-Options: nosniff`

        nginXの場合は

        `add_header X-Content-Type-Options: nosniff;`

        で指定することができる。
      - 必要に応じてContent-Dispositionを設定する

        `Content-Disposition: attachment; filename="hogehoge.gif"`

        `attachment` は、ファイルを開きたいわけではなくて、ダウンロードするだけで大丈夫な場合に指定する。オプション属性の `filename` には、ファイルを保存する際のデフォルトのファイル名を指定する。
      - その他の対策
        - 画像として読み込めるかチェック
        - ウィルス・スキャン
        - コンテンツの内容チェック（著作権を侵害するコンテンツみたいな良くないコンテンツじゃないかどうか）

### 4.12.4 PDFのFormCalcによるコンテンツハイジャック

  - 概要

    PDFではFormCalcというスクリプト言語が使用できて、FormCalcを使って、PDFドキュメントにスクリプトを埋め込むことができる。<br>FormCalcが用意している関数の中でURL関数があり、この関数を使って、仕掛けを組み込んでpdfをアップロードすることによって、なりすましを行う攻撃手法が行われる可能性がある。対象となるブラウザは、Adobe Acrobat Readerブラグインを備えたブラウザ。（IEなど。）

  - 攻撃手法

    - 攻撃者がFormCalcで書いたスクリプトを埋め込んだpdfファイルと罠ページを用意
    - 罠ページのFormCalcがHTTPリクエストを呼び出し、結果を受け取る

  - 対策

    - pdfファイルはブラウザ内で開かないでダウンロードするように強制する

      ブラウザ自体でAdobe Acrobat Readerプラグインが動作してしまうと、どうあがいてもFormCalcスクリプトが実行されてしまうため、pdfをブラウザ上で開かないで、ダウンロードしてから開いてもらうようにするのが有効。<br>レスポンスメッセージでヘッダを出力する際に、 `X-Download-Options: noopen` を指定することによって、ブラウザ上で「ファイルを開く」というボタンが表示されなくなる。

    - pdfをobject要素やembed要素では開けない仕組みを実装する

      `X-Download-Options: noopen` でダウンロードを強制できたとしても、罠のサイトでobject要素やembed要素を用いられていると、このヘッダは無視されて、スクリプトが実行されてしまうため、前述した対策と合わせて、object要素やembed要素では開けないように設定をしておく必要がある。<br>
      POSTリクエストでダウンロードするように指定する方法がおすすめ。

## 4.13 (335p) インクルードにまつわる問題
### 4.13.1 ファイルインクルード攻撃
  - 概要

    スクリプト言語で別ファイルからソースなどを読み込む機能を使う際に、指定するファイル名を外部から指定できる場合、アプリケーションが意図しないファイルを指定してしまうことがある。これをファイルインクルード脆弱性という。特にPHPの場合は、設定次第では外部サーバーのURLをファイル名として指定できる。（リモート・ファイルインクルード）

    - ファイルインクルード攻撃による影響
      - Webサーバー内のファイルの閲覧による情報漏洩
      - 任意スクリプトの実行による影響
        - サイト改ざん
        - 不正な機能実行
        - 踏み台攻撃

    - ファイルインクルード脆弱性の対策
      - インクルードするパス名に外部からのパラメータを含めない
      - インクルードするパス名に外部からのパラメータを含める場合は、英数字のみにする

## 4.16

### Web API実装における脆弱性

#### 4.16.1 JSONとJSONPの概要
JSON: データ記述言語の1つ。Web APIでバックエンド側とフォトンとエンド側とのデータ交換形式としてよく用いられている。
JSONはJavaScriptのオブジェクトリテラルの形式が用いられ、名称と構文はJavaScriptにおけるオブジェクト記法に由来する。
JavaScriptの"eval"関数によってJSON文字列をJavaScriptのデータ形式に変換されていた。
→後に説明する点で危険である。

安全な変換方法
- サーバ側のJSONとオブジェクトの相互変換（PHP）：json_encode(), json_decode
- JavaScript側のJSONとオブジェクトの相互変換：JSON.stringify(), JSON.parse()

JSONP: scriptタグを用いてクロスドメイン（異なるドメインに存在する）データを取得する仕組み。関数呼び出しの形でデータを生成する。
（例）4g-004.html: <script src="… ?callback=display_time"></script> => 4g-003.phpでdisplay_time()を呼び出す

#### 4.16.2 JSONエスケープの不備
JSON文字列生成時のエスケープ処理に不備があると意図しないJavaScriptがJSONデータに混入する場合がある。

攻撃手法と影響
郵便番号の後に%2b"alert(document.domain)%2b"(+をエンコードしたもの)を付与することによってapiサーバのドメインを取得できる。

脆弱性が生まれる原因
- JSON文字列生成時に適切なエスケープ処理などが行われていない。
- JSONの評価にeval関数などを用いているか、JSONPを用いている。

対策
- 文字連結によるJSONデータ生成をやめ、信頼できるライブラリでJSONを生成する
- eval関数ではなく、JSON.parseなどの安全なAPIでJSONを解釈する
- JSONPを避け、CORSを用いたWeb APIに移行する

### 4.16.3 JSON直接閲覧によるXSS

#### 攻撃手法と影響
- 4g-011.phpのMIMEタイプはapplication/jsonであるべき→指定し忘れでtext/htmlを返している。
- P.396のURLでアクセス→JavaScriptが実行される

#### 脆弱性が生まれる原因
- MIMEタイプの間違い
- 古いIEがContent-Typeヘッダを無視する場合がある

#### 対策
- MIMEタイプを正しく設定する（必須）
- レスポンスヘッダX-Content-Type-Options: nosniffを出力する（強く推奨）←サポートが終了した古いIEのため
- 大なり記号、小なり記号をエスケープする（推奨）←XSSを発生させる文字が出現しなくなる
- XMLHttpRequestなどCORS対応の機能だけから呼び出されるようにする（推奨）←不正なリクエストをチェックする


### 4.16.4 JSONPのコールバック関数名によるXSS

#### 攻撃手法と影響
- 4g_015.php: Content-Typeヘッダを返していない→MIMEタイプがtext/htmlとなってしまう。
- 外部から指定されたJavaScriptが実行される。

#### 脆弱性が生まれる原因
- 外部から指定されたコールバック関数名を検証しないでそのまま表示している。
- MIMEタイプをtext/javascriptとすべきところをtext/htmlとしている。

#### 対策
- コールバック関数名の文字の種類と文字数を制限する（英数字と_のみなど、「<」「>」を制限する）
- MIMEタイプを正しく設定する

###　4.16.5 Web APIのクロスサイト・リクエストフォージェリ
###　Web APIに対するCSRF攻撃経路

- GETリクエストによる攻撃　← パラメータは攻撃者が自由に設定できる
- HTMLフォームによる攻撃　← MIMEタイプをチェックしていない場合、HTMLフォームから攻撃できる
- クロスオリジン対応のXMLHttpRequestによる攻撃(シンプルなリクエスト)　← P.407~409の例の場合、CSRF攻撃はHTTPリクエストを送るだけで成立する
- クロスオリジン対応のXMLHttpRequestによる攻撃(プリフライトリクエストが必要なケース)　←　プリフライトリクエストの処理が不適切な場合、プリフライトリクエストまで許容してしまう。
###　対策

- CSRFトークン（セッション変数にトークンを保持）
- 二重送信クッキー（クッキーモンスターバグなどの問題点あり）　→ 乱数によるトークンをクッキーとして保存、同じ値をリクエストヘッダのパラメータとして別に送信する。
- カスタムリクエストヘッダによる対策　→ カスタムリクエストヘッダを付与し、サーバ側で確認することでCSRF対策になる。
共通の対策として、、
- 入力データのMIMEタイプを検証
- CORSを適切に実装する
###　4.16.6 JSONハイジャック
###　攻撃手法と影響
JSONハイジャック：何らかの方法でJSONデータをscript要素で受け取ろうとする攻撃
古いバージョンのブラウザの脆弱性であり、いずれもブラウザ側で対策されている

###　対策

- X-Content-Type-Options: nosniffヘッダの付与（強く推奨）
- リクエストヘッダX-Requested-With: XMLHttpRequestの確認（推奨）
###　4.16.7 JSONPの不適切な利用
- JSONPはできるだけ使用せず、CORS+JSONに移行する
- JSONPは公開情報の提供のみに用いる
- JSONPは信頼できる提供元のみを使用する

### 4.16.7 JSONPの不適切な利用
- JSONPはできるだけ使用せず、CORS+JSONに移行する
- JSONPは公開情報の提供のみに用いる
- JSONPは信頼できる提供元のみを使用する

### 4.16.8 CORSの検証不備
- オリジンとして"*"を指定する → オリジンの制限がある場合、原則としてオリジンを明示する
- オリジンのチェックをわざと緩和する → XMLHttpRequestのwithCredentialsプロパティを指定した場合、Access-Control-Allow-Originヘッダに指定する
  オリジンは明示しなければならない(必要な許可だけを与えるべき)

### 4.16.9 セキュリティを強化するレスポンスヘッダ
- X-Frame-Options: クリックじゃっキングやiframeなどを用いた攻撃を防止する。
- X-Content-Type-Options: MIMEタイプをブラウザに誤認させる攻撃やJSONハイジャック攻撃などを緩和する。
- X-XSS-Protection: XSSフィルタを利用するためのヘッダ
- Content-Security-Policy: XSS攻撃を緩和するためのセキュリティ機能
- Strict-Transport-Security: HTTPSでの接続を強制するための指令


![image](https://github.com/maki-engineer/circle-reading/assets/130033908/3cf87b73-2c4e-4122-8bc5-42b6892049ca)


